<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-ietf-jose-use-cases-03"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->

    <title abbrev="JOSE Use Cases">Use Cases and Requirements for JSON Object
    Signing and Encryption (JOSE)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <author fullname="Richard Barnes" initials="R.L." surname="Barnes">
      <organization>BBN Technologies</organization>

      <address>
        <postal>
          <street>1300 N 17th St</street>

          <city>Arlington</city>

          <region>VA</region>

          <code>22209</code>

          <country>US</country>
        </postal>

        <email>rlb@ipv.sx</email>
      </address>
    </author>

    <date year="2013"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <area>SEC</area>

    <workgroup>JOSE</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>JWS, JWE, JWK, JWA, JWT, CMS, S/MIME, JOSE, XMPP, ALTO, OAuth</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>
        多くのインターネット上のアプリケーションは, ネットワークレイヤーやトランスポートレイヤーでのセキュリティメカニズムに加えて, オブジェクトベースのセキュリティメカニズムを必要とする.
        かつては Cryptographic Message Syntax (CMS) が ASN.1 に基づいたバイナリレベルでのセキュアオブジェクトフォーマットを提供していた.
        しかしながら時代の変化とともに ASN.1 のようなバイナリオブジェクトエンコーディングは時代遅れとなり, JSON などのテキストベースエンコーディングが主流となった.
        本ドキュメントでは, 現在実用化されている様々なアプリケーションレイヤーセキュリティメカニズムをもとに, JSON ベースのセキュアオブジェクトフォーマットの各種ユースケースと要件をまとめる.
      </t>
      <!--
      <t>Many Internet applications have a need for object-based security
      mechanisms in addition to security mechanisms at the network layer or
      transport layer. In the past, the Cryptographic Message Syntax (CMS) has
      provided a binary secure object format based on ASN.1. Over time, the
      use of binary object encodings such as ASN.1 has been overtaken by
      text-based encodings, for example JavaScript Object Notation. This
      document defines a set of use cases and requirements for a secure object
      format encoded using JavaScript Object Notation (JSON), drawn from a variety of
      application security mechanisms currently in development.</t>
      -->
    </abstract>
  </front>

  <middle>
    <section anchor="intro-sec" title="Introduction">
      <t>
        インターネット上のアプリケーションは, インターネットを構成する各レイヤーにおけるセキュリティメカニズムを活用できる.
        多くのアプリケーションは, IPSec や TLS などの, チャネルベースのセキュリティに大きく依存している.
        これらのセキュリティメカニズムは, アプリケーションデータが流れる IP レイヤーやトランスポートレイヤーにおいてセキュアチャネルを確立するものである.
        <xref target="RFC4301"/>
        <xref target="RFC5246"/>
        しかしながらこれらのセキュリティメカニズムは状況によっては end-to-end のセキュリティを保証しない.
        例えば, アプリケーションレイヤーに仲介者が存在する場合は, チャネルベースのセキュリティプロトコルでは, 仲介者同士の間を流れるメッセージを改竄しようとするアタッカーからの攻撃は防ぐことができても, 仲介者自身がメッセージを改竄 / 盗聴することは防げない.
        こういったケースでは, オブジェクトベースのセキュリティメカニズムを用いてアプリケーションデータをセキュアオブジェクトに埋め込み, 信頼できない主体がデータを扱ってもセキュリティを確保できるようにする必要がある.
      </t>
      <!--
      <t>Internet applications rest on the layered architecture of the
      Internet, and take advantage of security mechanisms at all layers. Many
      applications rely primarily on channel-based security technologies such as
      IPsec and TLS,
      which create a secure channel at the IP layer or transport layer over
      which application data can flow <xref target="RFC4301"/><xref
      target="RFC5246"/>. These mechanisms, however, cannot provide end-to-end
      security in some cases. For example, in protocols with application-layer
      intermediaries, channel-based security protocols would protect messages
      from attackers between intermediaries, but not from the intermediaries
      themselves. These cases require object-based security technologies,
      which embed application data within a secure object that can be safely
      handled by untrusted entities.</t>
      -->

      <t>
        上記のようなプロトコルとして現在最も広く利用されているのは, Secure/Multipurpose Internet Mail Extensions (S/MIME) である.
        Email メッセージは, 通常一連の Mail Transfer Agents (MTA) を仲介者として, 受信者に届けられる.
        これら MTA は通常チャネルベースのセキュリティメカニズムを用いて通信を保護する (例: STARTTLS <xref target="RFC3207"/>) が, こういった仕組みは MTA 自身がメッセージを改竄 / 盗聴することを防ぐものではない.
        信頼できない MTA が存在する状況でも end-to-end のセキュリティを確保するには, S/MIME を利用してメッセージボディーをセキュアオブジェクトに内包し, 情報の機密性 (confidentiality), 完全性 (integrity), 送信者認証 (data origin authentication) を確保することが有効である.
      </t>
      <!--
      <t>The most well-known example of such a protocol today is the use of
      Secure/Multipurpose Internet Mail Extensions (S/MIME) protections within
      the email system <xref target="RFC5751"/><xref target="RFC5322"/>. An
      email message typically passes through a series of intermediate Mail
      Transfer Agents (MTAs) en route to its destination. While these MTAs
      often apply channel-based security protections to their interactions
      (e.g., STARTTLS <xref target="RFC3207"/>), these protections do not prevent the
      MTAs from interfering with the message. In order to provide end-to-end
      security protections in the presence of untrusted MTAs, mail users can
      use S/MIME to embed message bodies in a secure object format that can
      provide confidentiality, integrity, and data origin authentication.</t>
      -->

      <t>
        S/MIME は Cryptographic Message Syntax for secure objects (CMS) <xref target="RFC5652"/> をベースにしている.
        CMS は Abstract Syntax Notation 1 (ASN.1) を用いて定義され, 慣習的に ASN.1 Distinguished Encoding Rules (DER) でエンコードされる.
        DER では保護されるメッセージと関連パラメーターはバイナリエンコーディングされる. <xref target="ITU.X690.2002"/>
        近年では ASN.1 (やその他の汎用オブジェクトに対するバイナリエンコーディング) が利用されるケースは減少し, Extensible Markup Language (XML) <xref target="W3C.REC-xml"/> や JavaScript Object Notation (JSON) <xref target="RFC4627"/> といったテキストベースのフォーマットの利用が増加している.
      </t>
      <!--
      <t>S/MIME is based on the Cryptographic Message Syntax for secure
      objects (CMS) <xref target="RFC5652"/>. CMS is defined using Abstract
      Syntax Notation 1 (ASN.1) and traditionally encoded using the ASN.1
      Distinguished Encoding Rules (DER), which define a binary encoding of
      the protected message and associated parameters <xref
      target="ITU.X690.2002"/>. In recent years, usage of ASN.1 has decreased
      (along with other binary encodings for general objects), while more
      applications have come to rely on text-based formats such as the
      Extensible Markup Language (XML) <xref target="W3C.REC-xml"/> or the JavaScript Object Notation
      (JSON) <xref target="RFC4627"/>.</t>
      -->

      <t>
        最近の多くのアプリケーションは ASN.1 オブジェクトよりも遥かにテキストベースフォーマットのオブジェクトの処理に長けており, そもそも ASN.1 オブジェクトを処理できないものも多い.
        オブジェクトベースのセキュリティの実装を単純化するため, IETF JSON Object Signing and Encryption (JOSE) ワーキンググループでは JSON ベースのセキュアオブジェクトフォーマットを策定している.
        その名前が示す通り, ここで策定されているのは JSON エンコードされたオブジェクトの機密性 (confidentiality), 完全性 (integrity) を確保するためのフォーマットである.
        しかしながら, ワーキンググループ内での議論の結果, JOSE で定義されるフォーマットを利用するアプリケーションごとに, そのフォーマットに対する要件が異なることも分かった.
        よって本ドキュメントでは, JOSE フォーマットを利用する可能性のあるアプリケーションを想定し, セキュリティメカニズムとオブジェクトエンコーディングに対する要件をまとめる.
      </t>
      <!--
      <t>Many current applications thus have much more robust support for
      processing objects in these text-based formats than ASN.1 objects;
      indeed, many lack the ability to process ASN.1 objects at all. To
      simplify the addition of object-based security features to these
      applications, the IETF JSON Object Signing and Encryption (JOSE) working
      group has been chartered to develop a secure object format based on
      JSON. While the basic requirements for this object format are
      straightforward -- namely, confidentiality and integrity mechanisms,
      encoded in JSON -- discussions in the working group indicated that
      different applications hoping to use the formats defined by JOSE have
      different requirements. This document summarizes the use cases for JOSE
      envisioned by those potential applications and the resulting requirements for
      security mechanisms and object encodings.</t>
      -->

      <t>
        XML を利用するシステムでは, XML ベースのオブジェクトベースセキュリティメカニズムである XML Digital Signatures および XML Encryption を利用するものもある.
        <xref target="W3C.xmldsig-core"/>
        <xref target="W3C.xmlenc-core"/>
        これらは SAML <xref target="OASIS.saml-core-2.0-os"/> や WS-Federation <xref target="WS-Federation"/> などのセキュリティトークンや CAP 緊急アラートフォーマット <xref target="CAP"/> での利用を想定して定義されたものである.
        しかし現実には XML ベースのセキュアオブジェクトフォーマットは ASN.1 と同レベルの複雑性を持ち, ASN.1 を扱えない / 扱いたくないデベロッパーがこういった XML ベースのセキュリティメカニズムを利用することは考えづらい.
        こういった背景が, JSON ベースのセキュアオブジェクトフォーマット策定に至る動機となっている.
        JSON ベースであれば, 実装や利用も容易であり, 開発者はわずかな労力とツールのみでそれを取り入れることができるであろう.
      </t>
      <!--
      <t>Some systems that use XML have specified the use of XML-based
      security mechanisms for object security, namely XML Digital Signatures
      and XML Encryption <xref target="W3C.xmldsig-core"/><xref
      target="W3C.xmlenc-core"/>. These mechanisms are defined
      for use with several security token systems (e.g.,
      SAML <xref target="OASIS.saml-core-2.0-os"/> and
      WS-Federation <xref target="WS-Federation"/>) and the CAP
      emergency alerting format <xref target="CAP"/>. In practice, however,
      XML-based secure object formats introduce similar levels of complexity
      to ASN.1, so developers that lack the tools or motivation to handle
      ASN.1 aren't likely to use XML security either. This situation motivates
      the creation of a JSON-based secure object format that is simple enough
      to implement and deploy that it can be easily adopted by developers with
      minimal effort and tools.</t>
      -->
    </section>

    <section anchor="def-sec" title="Definitions">
      <!--
      <t>The key words "must", "must NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
      -->

      <t>この文書は<xref target="RFC4949"/>に記載される標準セキュリティ用語を広範囲に活用するものである。
          JOSEとCMSのユースケースは似ていることから、いくつかのCMSのコンセプトについて<xref target="RFC5652"/>を例に説明する。</t>
      <!--
      <t>This document makes extensive use of standard security terminology
      <xref target="RFC4949"/>. In addition, because the use cases for JOSE
      and CMS are similar, we will sometimes make analogies to some CMS
      concepts <xref target="RFC5652"/>.</t>
      -->

      <t>JOSEワーキンググループでは３つのJSONオブジェクトフォーマットを定義する。
      <!--
      <t>The JOSE working group charter calls for the group to define three
      basic JSON object formats:
      -->
      <list style="numbers">
          <t>機密性保護オブジェクトフォーマット</t>
          <!--<t>Confidentiality-protected object format</t>-->

          <t>完全性保護オブジェクトフォーマット</t>
          <!--<t>Integrity-protected object format</t>-->

          <t>鍵表現フォーマット</t>
          <!--<t>A format for expressing keys</t>-->
      </list>

      この文書では、上記をそれぞれ"署名済みオブジェクトフォーマット"、"暗号化オブジェクトフォーマット"、"鍵フォーマット"と呼ぶ。
      これらのフォーマットを表現することを目的としたJOSEワーキンググループの仕様はそれぞれJSON Web Signature (JWS)<xref target="I-D.ietf-jose-json-web-signature"/>, JSON Web Encryption (JWE)<xref target="I-D.ietf-jose-json-web-encryption"/>, JSON Web Key (JWK)<xref target="I-D.ietf-jose-json-web-key"/>である。
      JWS, JWE, JWKで使用されるアルゴリズムやアルゴリズム識別子はJSON Web Alogrithms (JWA) <xref target="I-D.ietf-jose-json-web-algorithms"/> で定義されている。
      <!--In this document, we will refer to these as
      the "signed object format",
      the "encrypted object format",
      and the "key format", respectively.
      The JOSE working group items intended to describe these formats are
      JSON Web Signature (JWS), JSON Web Encryption (JWE), and JSON Web Key (JWK),
      respectively <xref target="I-D.ietf-jose-json-web-signature"/>
      <xref target="I-D.ietf-jose-json-web-encryption"/>
      <xref target="I-D.ietf-jose-json-web-key"/>.
      Algorithms and algorithm identifiers used by JWS, JWE, and JWK are defined in
      JSON Web Algorithms (JWA) <xref target="I-D.ietf-jose-json-web-algorithms"/>.-->
      </t>

      <t>通常、非対称/対称な処理を区別する必要がない場面では、共通鍵を使ったメッセージ認証コード(MAC) と公開鍵暗号を含むデジタル署名についても同様に"署名"、"シグネチャ"などの用語を用いる</t>
      <!--<t>In general, where there is no need to distinguish between asymmetric and
      symmetric operations, we will use the terms "signing", "signature", etc.
      to denote both true digital signatures involving asymmetric cryptography
      as well as message authentication codes using symmetric keys (MACs).</t>-->

      <t>セキュアオブジェクトの存続期間には、オブジェクトを生成するエンティティ（例：ペイロードを暗号化もしくは署名する側）とオブジェクトを利用するエンティティ（例：復号化、検証をする側）の２つの基本的なロールが存在する。
          これらのロールをそれぞれ"送信者"、"受信者"と呼ぶことにする。
          要件やユースケースによってはこれらのロールを単一エンティティが担うことを明記するかもしれないが、同一ロールに複数のエンティティが存在する可能性があることに留意すること。
          たとえば、メッセージは複数の送信者によって署名されたり、複数の受信者によって復号化される可能性がある。</t>
      <!--<t>In the lifespan of a secure object, there are two basic roles, an
      entity that creates the object (e.g., encrypting or signing a payload),
      and an entity that uses the object (decrypting, verifying). We will
      refer to these roles as "sender" and "recipient", respectively. Note
      that while some requirements and use cases may refer to these as single
      entities, each object may have multiple entities in each role. For
      example, a message may be signed by multiple senders, or decrypted by
      multiple recipients.</t>-->
    </section>

    <section anchor="basic-sec" title="Basic Requirements">
      <t>
        言うまでもなく、 暗号化および署名済みオブジェクトフォーマットに対し、機密性のためには対称あるいは非対称暗号化、完全性保護のためにはMACあるいはデジタル署名といった、適切な暗号メカニズムを用いることで、必要な保護が形成される。
        両方のケースで、対称および非対称処理の両方のサポートがJOSEフォーマットには必要である。
        <list style="symbols">
          <t>
            JOSE暗号化オブジェクトフォーマットは、送信者と受信者が対称鍵を共有しているケースでのオブジェクト暗号化をサポートしなければならない。
          </t>

          <t>
            JOSE暗号化オブジェクトフォーマットは、送信者が受信者の公開鍵のみを所持しているケースでのオブジェクト暗号化をサポートしなければならない。
          </t>

          <t>
            JOSE署名済みオブジェクトフォーマットは、送信者と受信者が対称鍵のみを共有しているケースでのメッセージ認証コード (MAC) を用いた完全性保護をサポートしなければならない。
          </t>

          <t>
            JOSE署名済みオブジェクトフォーマットは、受信者が送信者の公開鍵のみを所持しているケースでのデジタル署名を用いた完全性保護をサポートしなければならない。
          </t>
        </list>
      </t>
      <!--
      <t>Obviously, for the encrypted and signed object formats, the necessary
      protections will be created using appropriate cryptographic mechanisms:
      symmetric or asymmetric encryption for confidentiality and MACs or
      digital signatures for integrity protection. In both cases, it is
      necessary for the JOSE format to support both symmetric and asymmetric
      operations.<list style="symbols">
          <t>The JOSE encrypted object format must support object encryption
          in the case where the sender and receiver share a symmetric key.</t>

          <t>The JOSE encrypted object format must support object encryption
          in the case where the sender has only a public key for the
          receiver.</t>

          <t>The JOSE signed object format must support integrity protection using
          Message Authentication Codes (MACs), for the case where the sender
          and receiver share only a symmetric key.</t>

          <t>The JOSE signed object format must support integrity protection using
          digital signatures, for the case where the receiver has only a
          public key for the sender.</t>
        </list></t>
      -->
      <t>
        いくつかのアプリケーションでは、JOSEオブジェクトの処理に用いる鍵が、JOSEオブジェクトの中で直接提示されるのではなく、アプリケーションのコンテキストを通じて提示される。
        しかし、混乱を避けるために、必要なコンテキストが不足しているエンドポイントは、不足を認識し、問題なく失敗処理を行える必要がある。
        鍵以外、JOSEオブジェクトは事前ネゴシエーションをサポートしない。
        全ての暗号パラメータはJOSEオブジェクトの中に直接記述されなければならない。
        <list style="symbols">
          <t>
             JOSE署名済みおよび暗号化オブジェクトフォーマットは、対象のオブジェクトの処理に必要な鍵を持っているかどうか、そしてその鍵はそのオブジェクト自身によって提示されているか、あるいはなんらかのout-of-bandメカニズムによって提示されているかどうかについて実装が認識するためのプロセスを定義しなければならない。
          </t>
          <t>
            JOSEで利用される各アルゴリズムについて、そのアルゴリズムを使用するJOSEオブジェクトが内包しなければならないパラメータを定義する必要がある。
          </t>
        </list>
      </t>
      <!--
      <t>In some applications, the key used to process a JOSE object is indicated
      by application context, instead of directly in the JOSE object.  However,
      in order to avoid confusion, endpoints that lack the necessary context need
      to be able to recognize this and fail cleanly.  Other than keys, JOSE objects
      do not support pre-negotiation; all cryptographic parameters must be expressed
      directly in the JOSE object.
          <list style="symbols">
          <t>The JOSE signed and encrypted object formats must define the process
          by which an implementation recognizes whether it has the key required
          to process a given object, whether the key is specified by the
          object or by some out-of-band mechanism.</t>
          <t>Each algorithm used for JOSE must define which parameters are
          required to be present in a JOSE object using that algorithm.</t>
          </list>
      </t>
      -->
      <t>
        二つのエンティティが複数のJOSEオブジェクトを交換しようとするケースで、全てのJOSEオブジェクトで個々にパラメータを記述しなくても済むように、いくつかのパラメータについて事前にネゴシエーションをすることは有用かもしれない。
        しかし、事前ネゴシエーションをサポートしないエンドポイントと混同しないように、これらのケースでは事前にネゴシエーションされたパラメータを使用していることを示すことは有益である。

        <list style="symbols">
          <t>
            オブジェクトの処理に事前ネゴシエーションされたパラメータが使用されることを示すことができるように、基本のJOSE署名済みおよび暗号化オブジェクトフォーマットを拡張できるようにすべきである。
            この拡張は、どのパラメータが使用されるのかを示す手段も提供すべきである。
          </t>
        </list>
      </t>
      <!--
      <t>In cases where two entities are going to be exchanging several JOSE
      objects, it might be helpful to pre-negotiate some parameters so that
      they do not have to be signaled in every JOSE object.  However,
      so as not to confuse endpoints that do not support pre-negotiation,
      it is useful to signal when pre-negotiated parameters are in use in those cases.
          <list style="symbols">
          <t>It should be possible to extend the base
	  JOSE signed and encrypted object formats
	  to indicate that pre-negotiated parameters are to be used to
          process the object.  This extension should also provide a means of indicating of
          which parameters are to be used.</t>
          </list>
      </t>
      -->

      <t>
        鍵フォーマットの目的は、暗号メッセージ処理用の符号化された鍵を使用するために十分な情報を受信者に提供することである。
        そのため、時には純粋な鍵だけではなく追加のパラメータを含める必要がある。
      </t>
      <!--
      <t>The purpose of the key format is to provide the recipient with
      sufficient information to use the encoded key to process cryptographic
      messages. Thus it is sometimes necessary to include additional parameters along
      with the bare key.</t>
      -->

      <t>
        <list style="symbols">
          <t>
            JOSE鍵フォーマットは符号化された鍵を使用するために必要な全てのアルゴリズムパラメータを含めることが出来なければならない。
            そのパラメータには、アルゴリズムで必要となる追加のパラメータ (例: 楕円曲線パラメータ) とともに、その鍵が使用されるアルゴリズムの識別子も含まれる。
          </t>
        </list>
      </t>
      <!--
      <t><list style="symbols">
          <t>The JOSE key format must enable inclusion of all algorithm parameters
          necessary to use the encoded key, including an identifier for the
          algorithm with which the key is used as well as any additional
          parameters required by the algorithm (e.g., elliptic curve
          parameters).</t>
        </list></t>
      -->
    </section>

    <section anchor="app-req-sec" title="Requirements on Application Protocols">
      <t>
        各 JOSE セキュアオブジェクトフォーマット仕様は, 保護対象コンテンツに対する暗号処理を詳細に定め, JOSE オブジェクトの受信者が, 適切に暗号化されたオブジェクトを復号したり, 署名を検証したりできることを保証する.
        しかしながら, JOSE を利用する各アプリケーション側でも, 以下のような点については独自に定める必要がある.
        <list style="symbols">
          <t>保護対象となるアプリケーションコンテンツ</t>
          <t>利用される暗号アルゴリズム</t>
          <t>エンティティ間での鍵確立手法</t>
          <t>利用される鍵が JOSE オブジェクト内に明示的に示されているのか, アプリケーションのコンテキストにより決まるのか</t>
        </list>
      </t>
      <!--
      <t>
        The JOSE secure object formats describe how cryptographic processing is
        done on secured content, ensuring that the recipient an object is able
        to properly decrypt an encrypted object or verify a signature.  In order
        to make use of JOSE, however, applications will need to specify several
        aspects of how JOSE is to be used:
        <list style="symbols">
          <t>What application content is to be protected</t>
          <t>Which cryptographic algorithms are to be used</t>
          <t>How application protocol entities establish keys</t>
          <t>Whether keys are to be explicitly indicated in JOSE objects, or
             associated by application context</t>
        </list>
      </t>
      -->
    </section>

    <section anchor="use-cases-sec" title="Use Cases">
        <t>アプリケーションレイヤーのプロトコルについて策定しているワーキンググループにはJOSEデータフォーマットをエンドツーエンドのセキュリティ機能の設計で利用したいという要望を表明しているところもある。
            この章では、このようなグループが提案したユースケースをとりまとめ、JOSEオブジェクトフォーマットに求められる要件について説明する。</t>
      <!--<t>Several working groups developing application-layer protocols
      have expressed a desire to use the JOSE data formats in their
      designs for end-to-end security features. In this section, we summarize
      the use cases proposed by these groups and discuss the requirements that
      they imply for the JOSE object formats.</t>-->

      <section anchor="sec-token-sec" title="Security Tokens">
        <t>セキュリティトークンはオブジェクトベースのセキュリティではよくあるユースケースである。例えばSAMLのアサーション <xref target="OASIS.saml-core-2.0-os"/>がある。
            セキュリティトークンは発行者から受信者へ対象のエンティティ（"クレーム"または"アサーション"）に関する情報を渡すために使われる。
            トークンフォーマットのセキュリティ機能により、受信者はクレームが発行者により発行され、完全性が保護されているオブジェクトの場合は他のパーティから読み取れないことを検証することができる。</t>
        <!--<t>Security tokens are a common use case for object-based security,
        for example, SAML assertions <xref target="OASIS.saml-core-2.0-os"/>.
        Security tokens are used to convey information about a subject entity
        ("claims" or "assertions") from an issuer to a recipient. The security
        features of a token format enable the recipient to verify that the
        claims came from the issuer and, if the object is
        confidentiality-protected, that they were not visible to other
        parties.</t>-->

        <t>セキュリティトークンはOAuth2.0<xref target="RFC6749"/>とそれに含まれるOAuth bearer tokens <xref target="RFC6750"/> などのリソース認可のプロトコルだけでなく、SAML 2.0 <xref target="OASIS.saml-core-2.0-os"/>, WS-Federation <xref target="WS-Federation"/>, Mozilla Persona <xref target="Persona"/>, OpenID Connect <xref target="OpenID.Messages"/> などのフェデレーションプロトコルで利用される。
            あるケースでは、セキュリティトークンはクライアント認証やアクセス制御 <xref target="I-D.ietf-oauth-jwt-bearer"/><xref target="I-D.ietf-oauth-saml2-bearer"/>に利用される。</t>
        <!--<t>Security tokens are used in federation protocols such as SAML 2.0
	<xref target="OASIS.saml-core-2.0-os"/>,
        WS-Federation <xref target="WS-Federation"/>,
	Mozilla Persona <xref target="Persona"/>,
	and OpenID Connect <xref target="OpenID.Messages"/>,
	as well as in resource authorization
        protocols such as OAuth 2.0 <xref target="RFC6749"/>,
	including for OAuth bearer tokens <xref target="RFC6750"/>. In some cases,
        security tokens are used for client authentication and for access
        control <xref target="I-D.ietf-oauth-jwt-bearer"/><xref
        target="I-D.ietf-oauth-saml2-bearer"/>.</t>-->

	<t>JSON Web Token (JWT) <xref target="I-D.ietf-oauth-json-web-token"/> はJSONおよびJOSEをベースとしたセキュリティートークンフォーマットである。
        JWTはMozilla Persona, OpenID Connect, OAuthと共に利用される.
        JWTは限定された場面（例: HTTPクエリパラメータ）で主に利用されていたためJWTの主要な要件となり、それゆえJOSEは短くURLセーフな形式になっている。</t>
	<!--<t>JSON Web Token (JWT) <xref target="I-D.ietf-oauth-json-web-token"/>
	is a security token format
	based on JSON and JOSE. It is used with Mozilla Persona,
	OpenID Connect, and OAuth. Because JWTs are often used in contexts
	with limited space (e.g., HTTP query parameters), it is a core
	requirement for JWTs, and thus JOSE, to have a compact, URL-safe
	representation.</t>-->
      </section>

      <section anchor="oauth-sec" title="OAuth">

        <t>
          OAuthプロトコルは、HTTP <xref target="RFC6749"/> を用いた認可トークンの流通と利用のメカニズムを定義している。
          保護リソースへアクセスしたいクライアントは、リソースオーナーからの認可を要求する。
          このアクセスを許可する場合、リソースオーナーは認可サーバーに対し、クライアントへアクセストークンを発行するよう指示する。
          クライアントは、保護リソースにアクセスしたいとき、関係するリソースサーバーにそのトークンを提示する。
          そしてリソースサーバーは保護リソースへのアクセスを提供する前にそのトークンの妥当性を検証する。
        </t>
        <!--
        <t>The OAuth protocol defines a mechanism for distributing and using
        authorization tokens using HTTP <xref target="RFC6749"/>. A Client
        that wishes to access a protected resource requests authorization from
        the Resource Owner. If the Resource Owner allows this access, he
        directs an Authorization Server to issue an access token to the
        Client. When the Client wishes to access the protected resource, he
        presents the token to the relevant Resource Server, which verifies the
        validity of the token before providing access to the protected
        resource.</t>
        -->

        <figure anchor="figOAuth" title="The OAuth process">
          <artwork><![CDATA[              +---------------+          +---------------+
              |               |          |               |
              |   Resource    |<........>| Authorization |
              |    Server     |          |     Server    |
              |               |          |               |
              +---------------+          +---------------+
                           ^                |
                           |                |
                           |                |
                           |                |
                           |                |
              +------------|--+          +--|------------+
              |            +----------------+            |
              |               |          |   Resource    |
              |     Client    |          |     Owner     |
              |               |          |               |
              +---------------+          +---------------+]]></artwork>

          <postamble/>
        </figure>

        <t>
          実質的にこのプロセスは、クライアントおよびリソースオーナー経由で、認可サーバー(オブジェクトの送信者)からリソースサーバー(受信者)へトークンを移すことである
          (リソースオーナーを経由するのはこのプロトコルが利用しているHTTPのメカニズムに起因している)。
          そこで、信頼できない中間者経由でアプリケーションオブジェクトを転送するケースが出てくる。
        </t>
        <!--
        <t>In effect, this process moves the token from the Authorization
        Server (as a sender of the object) to the Resource Server (recipient),
        via the Client as well as the Resource Owner (the latter because of
        the HTTP mechanics underlying the protocol). So again we have a case
        where an application object is transported via untrusted
        intermediaries.</t>
        -->

        <t>
          このアプリケーションには二つの不可欠なセキュリティ要件がある。
          完全性とデータ生成元の認証である。
          完全性保護は、リソースオーナーとクライアントがトークン内に符合化されたパーミッションを変更できないようするために必要である。
          リソースオーナーは究極的には認可を付与するエンティティではあるが、例えばリソースオーナーが所有していないリソースへのアクセス権の付与も出来てしまうため、認可トークンの変更に対しては信頼できない。
        </t>
        <!--
        <t>This application has two essential security requirements: Integrity
        and data origin authentication. Integrity protection is required so
        that the Resource Owner and the Client cannot modify the permission
        encoded in the token.  Although the Resource Owner is ultimately
        the entity that grants authorization, it is not trusted to modify the
        authorization token, since this could, for example, grant access to
        resources not owned by the Resource Owner.</t>
        -->

        <t>
          データ生成元の認証は、トークンが信頼できる認可サーバーによって生成されたものかどうかをリソースサーバーが検証できるようにするために必要である。
        </t>
        <!--
        <t>Data origin authentication is required so that
        the Resource Server can verify that the token was issued by a trusted
        Authorization Server. </t>
        -->

        <t>
          認可サーバーがリソースオーナーやクライアントに対してパーミッション情報を不可視としたい場合、機密性保護も必要となるかもしれない。
          例えば、ソーシャルネットワーキングに関連したパーミッションはプライベートな情報と見なされるかもしれない。
          しかし、OAuthは下位層で用いているHTTPトランザクションがTLSによって保護されていることを元々要求していることには注意すること。
          よってトークンはリソースサーバーとクライアント以外のエンティティに対する機密性保護に関しては既に達成されている。
        </t>
        <!--
        <t>Confidentiality protection may also be needed,
        if the Authorization Server is concerned about the visibility of
        permissions information to the Resource Owner or Client. For example,
        permissions related to social networking might be considered private
        information. Note, however, that OAuth already requires that the
        underlying HTTP transactions be protected by TLS, so tokens are
        already confidentiality-protected from entities other than
        the Resource Owner and Client.</t>
        -->

        <t>
          署名と暗号化が対称暗号または非対称暗号のいずれを用いて提供されるのかに関わらず、機密性および完全性のニーズは、署名済みおよび暗号化オブジェクトフォーマットの基本要件に合致している。
          どちらのメカニズムを採用するかの選択は、二つのサーバ間の関係、すなわちそれらが対称鍵を共有するのか、公開鍵のみを共有するのかに依存するだろう。
        </t>
        <!--
        <t>The confidentiality and integrity needs are met by the basic
        requirements for signed and encrypted object formats, whether the
        signing and encryption are provided using asymmetric or symmetric
        cryptography. The choice of which mechanism is applied will depend on
        the relationship between the two servers, namely whether they share a
        symmetric key or only public keys.</t>
        -->

        <t>
          認証の要件はデプロイの特性にも依存するだろう。
          リソースサーバーと認可サーバーの結びつけが相対的に強いところでは、トークンを発行した認可サーバを識別するにはトークンの署名に用いた鍵だけで十分かもしれない。
          これは、認可サーバーの公開鍵、あるいは公開鍵か対称鍵の識別子をプロトコルが伝送することを必要とする。
          OAuthでは <spanx style="verb">client_id</spanx> パラメータが、使用される鍵を識別する。
        </t>
        <!--
        <t>Authentication requirements will also depend on deployment
        characteristics. Where there is a relatively strong binding between
        the resource server and the authorization server, it may suffice for
        the Authorization Server issuing a token to be identified by the key
        used to sign the token. This requires that the protocol carry either the
        public key of the Authorization Server or an identifier for the public
        or symmetric key.  In OAuth, the <spanx style="verb">client_id</spanx>
        parameter identifies the key to be used.</t>
        -->

        <t>
          リソースサーバーは事前に認可サーバーの鍵を知らないといったような、より高度なケースも存在するかもしれない。
          例えば一つのエンティティが(負荷分散のために)複数の認可サーバーをインスタンス化する場合、それらが個々に独立した鍵ペアを持っている例が挙げられる。
          このようなケースの場合、対象の認可サーバーが信頼するエンティティかどうかをリソースサーバーが検証できるように、認可サーバーの証明書または証明書チェーンを含める必要もあるかもしれない。
        </t>
        <!--
        <t>There may also be more advanced cases, where the Authorization
        Server's key is not known in advance to the Resource Server. This may
        happen, for instance, if an entity instantiated a collection of
        Authorization Servers (say for load balancing), each of which has an
        independent key pair. In these cases, it may be necessary to also
        include a certificate or certificate chain for the Authorization
        Server, so that the Resource Server can verify that the Authorization
        Server is an entity that it trusts.</t>
        -->

        <t>
          OAuthにとってHTTPトランスポートはエンコーディングに関して特定の制約を課している。
          OAuthプロトコルでは、base64urlエンコーディング <xref target="RFC4648"/> が実施された上で、トークンはHTTP URI <xref target="RFC2616"/> 内のクエリーパラメータとして頻繁にやり取りされる。
          URI (従ってクエリパラメータも) の長さには制限が規定されていないが、実際にはいくつかのユーザーエージェントでは2048文字超のURIは拒否される。
          いくつかのモバイルブラウザでは、この制限はさらに小さな値となっている。
          そのためこのユースケースでは、JOSEオブジェクトに対して、URIクエリパラメータに含むことが可能なようシンプルであることと同時に、署名後 (場合によっては暗号化も) でも十分に小さなサイズであることを要求する。
        </t>
        <!--
        <t>The HTTP transport for OAuth imposes a particular constraint on the
        encoding. In the OAuth protocol, tokens frequently need to be passed
        as query parameters in HTTP URIs <xref target="RFC2616"/>, after
        having been base64url encoded <xref target="RFC4648"/>. While there is
        no specified limit on the length of URIs (and thus of query
        parameters), in practice, URIs of more than 2,048 characters are
        rejected by some user agents.  For some mobile browsers, this limit is
        even smaller. So this use case requires that a JOSE
        object have sufficiently small size even after signing, possibly
        encrypting, while still being simple to include in an HTTP URI query
        parameter.</t>
        -->
      </section>

      <section anchor="fed-sec" title="Federation">
        <t>
          セキュリティトークンは2つのアイデンティティフェデレーションプロトコルで用いられている.
          これら2つの要件は, 前節で述べたものと似ている.
        </t>
        <!--
        <t>Security tokens are used in two federated identity protocols,
        which have similar requirements to the general considerations discussed
        above:</t>
        -->

        <t><list style="symbols">
          <t>
            OpenID Connect <xref target="OpenID.Messages"/> は, OAuth 2.0 をベースとした REST/JSON ベースのシンプルなアイデンティティフェデレーションプロトコルである.
            OpenID Connect では, JWT および JOSE フォーマットがセキュリティトークンおよびその他のプロトコルメッセージの保護 (署名およびオプショナルで暗号化) の為に利用されている.
            OpenID Connect は, 暗号アルゴリズムのネゴシエーションや鍵情報の配送の為に, JWT/JOSE ヘッダーパラメーターとしては定義されていない要素を利用している.
          </t>
      <!--
	    <t>The OpenID Connect protocol <xref target="OpenID.Messages"/>
	    is a simple, REST/JSON-based
	    identity federation protocol layered on OAuth 2.0.
	    It uses the JWT and JOSE formats both
            to represent security tokens and to provide security for other
            protocol messages (performing signing and optionally encryption).
	    OpenID Connect negotiates the algorithms to be used and distributes
	    information about the keys to be used using protocol elements
	    that are not part of the JWT and JOSE header parameters.</t>
      -->

          <t>
            Mozilla Persona <xref target="Persona"/> は, アイデンティティ情報やアプリケーション情報, 関与する各エンティティの鍵情報などの表現形式として, JOSE JWS オブジェクトとして署名された JWT を利用した, シンプルなシングルサインオン (SSO) プロトコルである.
            Persona は鍵配送のために JOSE ヘッダーパラメータではなく JWT メッセージ中の属性を利用する.
          </t>
      <!--
	    <t>The Mozilla Persona <xref target="Persona"/> system is a simple
	    single-sign-on (SSO) protocol that uses JWTs that are signed
	    JOSE JWS objects to represent information about identities,
	    applications, and keys for participating entities.
	    Persona distributes the keys used as claims in JWT messages
	    and not by using JOSE header parameters.
	    </t>
      -->
          </list></t>
      </section>

      <section anchor="xmpp-sec" title="XMPP">
          <t>
              Extensible Messaging and Presence Protocol (XMPP) は末端のクライアントから他の端末へXMPP serversの仕様に従ってメッセージを送信するプロトコルである。<xref target="RFC6120"/>
              一般的には任意の送信メッセージに2つのサーバが関与する。
              あるクライアント(Alice) は他のクライアント (Bob) 宛のメッセージをサーバ(A)へ送信する。
              サーバAはBobのIDとDNSによってBobのドメイン(B)を持つサーバを特定し、メッセージをそのサーバへ送信する。その後サーバBはBobへメッセージを送信する。
          </t>
        <!--<t>The Extensible Messaging and Presence Protocol (XMPP) routes
        messages from one end client to another by way of XMPP servers <xref
        target="RFC6120"/>. There are typically two servers involved in
        delivering any given message: The first client (Alice) sends a message
        for another client (Bob) to her server (A). Server A uses Bob's identity
        and the DNS to locate the server for Bob's domain (B), then delivers
        the message to that server. Server B then routes the message to
        Bob.</t>-->

        <figure anchor="fig-xmpp" title="Delivering an XMPP message">
          <artwork><![CDATA[
         +-------+   +----------+   +----------+   +-----+
         | Alice |-->| Server A |-->| Server B |-->| Bob |
         +-------+   +----------+   +----------+   +-----+]]></artwork>
        </figure>

        <t>
            信頼できない中間者の問題については特にXMPPにとって深刻である。なぜならば、現時点で多くの適用例では、XMPPドメインの所有者がドメインのサーバの処理を他のエンティティに委託しているためである。
            この環境では、ドメイン所有者の個人情報がドメインのオペレーターに露出してしまう明白なリスクが存在する。
            XMPPはS/MIMEを利用して端末間セキュリティのメカニズム<xref target="RFC3923"/>を既に定義しているが、キー管理の問題やS/MIMEオブジェクトの処理が難しいこともあり、普及させることはできなかった。</t>
        <!--<t>The untrusted-intermediary problems are especially acute for XMPP
        because in many current deployments, the holder of an XMPP domain
        outsources the operation of the domain's servers to a different
        entity. In this environment, there is a clear risk of exposing the
        domain holder's private information to the domain operator. XMPP
        already has a defined mechanism for end-to-end security using S/MIME,
        but it has failed to gain widespread deployment <xref
        target="RFC3923"/>, in part because of key management challenges and
        because of the difficulty of processing S/MIME objects.</t>-->

        <t>
            XMPPワーキンググループはJOSEベースのエンコーディングとより明快なキー管理のシステムを利用した新しい端末間暗号化システムの策定に取り組んでいる。<xref target="I-D.miller-xmpp-e2e"/>
            このシステム上で暗号化メッセージを送信するプロセスは２つのステップからなる。
            1つ目は、送信者は対象な Content Encryption Key (CEK)を生成してメッセージコンテンツを暗号化して、暗号メッセージを届けたい先の受信者へ送信する。
            2つ目は、各受信者は自身の公開鍵を提示することで受信者へ「コールバック」を行い、送信者は受信者の公開鍵で変換された関連のあるCEKを受け取る。
        message to the desired set of recipients. Second, each recipient
        "dials back" to the sender, providing his public key; the sender then
        responds with the relevant CEK, wrapped with the recipient's public
        key.</t>
        <!--<t>The XMPP working group is in the process of developing a new
        end-to-end encryption system with an encoding based on JOSE and a
        clearer key management system <xref target="I-D.miller-xmpp-e2e"/>.
        The process of sending an encrypted message in this system involves
        two steps: First, the sender generates a symmetric Content Encryption
        Key (CEK), encrypts the message content, and sends the encrypted
        message to the desired set of recipients. Second, each recipient
        "dials back" to the sender, providing his public key; the sender then
        responds with the relevant CEK, wrapped with the recipient's public
        key.</t>-->

        <figure anchor="fig-xmpp-sec" title="Delivering a secure XMPP message">
          <artwork><![CDATA[
         +-------+   +----------+   +----------+   +-----+
         | Alice |<->| Server A |<->| Server B |<->| Bob |
         +-------+   +----------+   +----------+   +-----+
             |             |              |           |
             |------------Encrypted--message--------->|
             |             |              |           |
             |<---------------Public-key--------------|
             |             |              |           |
             |---------------Wrapped CEK------------->|
             |             |              |           |]]></artwork>
        </figure>

        <t>
            このシステムがJOSEフォーマットから要求する主要な事項は、コンテンツ部の暗号化による機密性保護に加え、共有鍵より導出したMACによる完全性の検証機能である。
            しかしながら、暗号コンテンツの送受信での鍵交換を区別するためには、JOSE暗号化オブジェクトフォーマットに暗号ペイロードとは区別して共通鍵を含むメッセージを伝達できるような仕組みが要求される。
            さらに、暗号オブジェクトにはコンテンツの暗号化に利用した鍵のタグが必要になる。そうすることで受信者(Bob)は送信者(Alice)へ鍵を含んだメッセージを送信する際にタグを提示することができる。
        </t>
        <!--<t>The main thing that this system requires from the JOSE formats is
        confidentiality protection via content encryption, plus an integrity
        check via a MAC derived from the same symmetric key. The separation of
        the key exchange from the transmission of the encrypted content,
        however, requires that the JOSE encrypted object format allow wrapped
        symmetric keys to be carried separately from the encrypted payload. In
        addition, the encrypted object will need to have a tag for the key
        that was used to encrypt the content, so that the recipient (Bob) can
        present the tag to the sender (Alice) when requesting the wrapped
        key.</t>-->

        <t>XMPPの重要な他の特徴は、複数の受信者へのメッセージの同時配信を許可していることである。
            上記のダイアグラムで言うと、サーバAはサーバB（Bobのサーバ）だけでなくほかのユーザの所有するサーバC, D, Eなどへもメッセージを配信できる。
            そのようなケースでは、上記の仕組みに示される複数の「コールバック」のトランザクションを回避するため、XMPPシステムは受信者の公開鍵をキャッシュすることがあり、それにより鍵はこの後のメッセージの内容と共に送信することができる。
            このことによりJOSE暗号オブジェクトフォーマットは複数バージョンものCEKの発行をサポートしなくてはならない。（CMS EnvelopedData structureでは複数の受信者情報の構造を含むことができるが）
        </t>
        <!--<t>Another important feature of XMPP is that it allows for the
        simultaneous delivery of a message to multiple recipients. In the
        diagrams above, Server A could deliver the message not only to Server
        B (for Bob) but also to Servers C, D, E, etc. for other users. In such
        cases, to avoid the multiple "dial back" transactions implied by the
        above mechanism, XMPP systems will likely cache public keys for end
        recipients, so that wrapped keys can be sent along with content on
        future messages. This implies that the JOSE encrypted object format
        must support the provision of multiple versions of the same wrapped
        CEK (much as a CMS EnvelopedData structure can include multiple
        RecipientInfo structures).</t>-->

        <t>
            XMPPの端末間セキュリティシステムの最新のドラフトでは、各パーティはXMPPメッセージ伝達システム内にある他パーティの信用情報にもとづいて認証される。
            送信者は、"Alice"という識別子宛のメッセージ（具体的には、隠蔽された鍵交換のためのリクエスト）を受け取ることができ、またその識別子宛のメッセージ（隠蔽された鍵情報）を送信できるため、受信者に認証される。
            同様に、受信者はオリジナルの暗号メッセージと元の鍵交換のリクエストを送ることができるため、送信者に認証される。
            そのため、ここでの認証で要求されるのはXMPPのルーティングが正しく行われることだけでなく、TLSが全てのホップにおいて使われることである。
            それに加えて、３ホップ中いずれかにおいて中間者によってBobになりすまして暗号メッセージの鍵情報を取得できてしまうため、強い認証強度のTLSチャネルが要求される。
        </t>
        <!--<t>In the current draft of the XMPP end-to-end security system, each
        party is authenticated by virtue of the other party's trust in the
        XMPP message routing system. The sender is authenticated to the
        receiver because he can receive messages for the identifier "Alice"
        (in particular, the request for wrapped keys), and can originate
        messages for that identifier (the wrapped key). Likewise, the receiver
        is authenticated to the sender because he received the original
        encrypted message and originated the request for wrapped key. So the
        authentication here requires not only that XMPP routing be done
        properly, but also that TLS be used on every hop. Moreover, it
        requires that the TLS channels have strong authentication, since a man
        in the middle on any of the three hops can masquerade as Bob and
        obtain the key material for an encrypted message.</t>-->

        <t>
            この認証は比較的脆弱（TLSを用いた３つのホップに依存しているため）でエンドポイントでは検証できない。 そのためXMPPワーキンググループは最終受信者のためになんらかのクレデンシャルを導入することも考えられる。 そのようなケースでは、そういったクレデンシャルをJOSEオブジェクトと関連づける方法も必要となるであろう。
        </t>
        <!--<t>Because this authentication is quite weak (depending on the use of
        transport-layer security on three hops) and unverifiable by the
        endpoints, it is possible that the XMPP working group will integrate
        some sort of credentials for end recipients, in which case there would
        need to be a way to associate these credentials with JOSE objects.</t>-->

        <t>
            最終的に、XMPPがJSONではなくXMLベースであることに意味はない。
            そのため、JOSEを利用するときは、XMPPはXML内にJSONオブジェクトを含めて送信される。
            したがって、JOSEオブジェクトはXMLに含まれても問題ないような方法でエンコードされることが望ましい。
            そうでなければ、XMLとしてパースされないように明示するため、明示的なCDATAの指定をパーサーに対して行わければならない。
            この要件を満たすひとつの方法としては、base64urlエンコードをかけることがあげられるが、中〜大サイズのXMPPメッセージにとっては、これによりかなりのオーバーヘッドを強いる可能性がある。
        </t>
        <!--<t>Finally, it's worth noting that XMPP is based on XML, not JSON. So
        by using JOSE, XMPP will be carrying JSON objects within XML. It is
        thus a desirable property for JOSE objects to be encoded in such a way
        as to be safe for inclusion in XML. Otherwise, an explicit CDATA
        indication must be given to the parser to indicate that it is not to
        be parsed as XML. One way to meet this requirement would be to apply
        base64url encoding, but for XMPP messages of medium-to-large size,
        this could impose a fair degree of overhead.</t>-->
      </section>

      <section anchor="alto-sec" title="ALTO">
        <t>
          Application-Layer Traffic Optimization (ALTO) は、エンド端末に対する分散ネットワークトポロジー情報のためのシステムであり、
          これによりエンド端末はネットワークへのインパクトを抑えつつ自らの動作を修正することが可能となる <xref target="RFC6708"/> 。
          ALTOプロトコルは、HTTP <xref target="RFC2616"/> で搬送するJSONオブジェクトの形態でトポロジー情報を分配する <xref target="I-D.ietf-alto-protocol"/> 。
          元々の版のALTOはシンプルなクライアントサーバプロトコルであり、このケースではHTTPSを単純に使用するだけで十分である <xref target="RFC2818"/> 。
          しかし、クライアントに到達する前に複数の中間サーバを経由してこれらのJSONオブジェクトが分配されるというALTOのユースケースの議論が始まり、
          一方でクライアントがオブジェクトのオリジナルの送信元を認証する機能は依然として維持する必要があった。
          元々のALTOプロトコルでも「ALTO情報を取得するALTOクライアントは、その受け取ったALTO情報が適切なALTOサーバーによって生成されたものかどうかの検証ができなければならない」という言及があった。
        </t>
        <!--
        <t>Application-Layer Traffic Optimization (ALTO) is a system for
        distributing network topology information to end devices, so that
        those devices can modify their behavior to have a lower impact on the
        network <xref target="RFC6708"/>. The ALTO protocol
        distributes topology information in the form of JSON objects carried
        in HTTP <xref target="RFC2616"/><xref
        target="I-D.ietf-alto-protocol"/>. The basic version of ALTO is simply
        a client-server protocol, so simple use of HTTPS suffices for this
        case <xref target="RFC2818"/>. However, there is beginning to be some
        discussion of use cases for ALTO in which these JSON objects will be
        distributed through a collection of intermediate servers before
        reaching the client, while still preserving the ability of the client
        to authenticate the original source of the object. Even the base ALTO
        protocol notes that "ALTO clients obtaining ALTO information must be
        able to validate the received ALTO information to ensure that it was
        generated by an appropriate ALTO server."</t>
        -->

        <t>
          このケースでのセキュリティ要件は明確である。
          ALTOペイロードを搬送するJOSEオブジェクトは、オリジナルの送信元サーバーのデジタル署名が付随している必要があり、
          そしてそのサーバーのアイデンティティを証明できなければならないだろう。
          ALTO情報は一般に公開されるものであるため、このケースでは機密性に関する要件はない。
        </t>
        <!--
        <t>In this case, the security requirements are straightforward. JOSE
        objects carrying ALTO payloads will need to bear digital signatures
        from the originating servers, which will be bound to certificates
        attesting to the identities of the servers. There is no requirement
        for confidentiality in this case, since ALTO information is generally
        public.</t>
        -->

        <t>
          より興味深い議題はエンコーディングに関することである。
          ALTOオブジェクトは前述の2つのケースよりもペイロードが大きくなる可能性があり、そのサイズは数メガバイトにまでなると考えられる。
          このような大きなオブジェクトの処理は、シングルパスで実施できた方がより高速に処理できる。
          そしてそれは、JSON構造内でフィールドが特定の順番であることをJOSEオブジェクトが要求することで可能となるだろう。
        </t>
        <!--
        <t>The more interesting questions are encoding questions. ALTO objects
        are likely to be much larger than payloads in the two cases above,
        with sizes of up to several megabytes. Processing of such large
        objects can be done more quickly if it can be done in a single pass,
        which may be possible if JOSE objects require specific orderings of
        fields within the JSON structure.</t>
        -->

        <t>
          加えて、ALTOオブジェクトはJSONとしてエンコードされているため、JOSEオブジェクト内に安全に包含することが可能である。
          署名済みのJOSEオブジェクトは、署名とともに署名されたデータを搬送するだろう。
          JSONオブジェクトは、JSON文字列内に安全にエンコードされて格納されることが可能という性質を持っている。
          これに関する要件は、不必要な空白は取り除くことだけであり、例えばbase64urlエンコーディングよりもかなりシンプルな変換である。
          このことは、特定の「JSON-safe」なケースでのJOSEエンコーディングを最適化できるかどうかという議題に繋がる。
        </t>
        <!--
        <t>In addition, because ALTO objects are also encoded as JSON, they
        are already safe for inclusion in a JOSE object. Signed JOSE objects
        will likely carry the signed data in a string alongside the signature.
        JSON objects have the property that they can be safely encoded in JSON
        strings. All they require is that unnecessary white space be removed,
        a much simpler transformation than, say base64url encoding. This
        raises the question of whether it might be possible to optimize the
        JOSE encoding for certain "JSON-safe" cases.</t>
        -->

        <t>
          最終的に、「分離署名 (detached signature)」メカニズム、つまり署名情報を保護対象のコンテンツから分離してエンコードする方法が、ALTOにとっては望ましいかもしれない。
          これはALTOプロトコルで、署名をHTTPSのヘッダ、署名されたコンテンツをHTTPSのエンティティボディに含めることを可能とするだろう。
        </t>
        <!--
        <t>Finally, it may be desirable for ALTO to have a "detached signature"
        mechanism, that is, a way to encode signature information separate
        from the protected content.  This would allow the ALTO protocol to
        include the signature in an HTTPS header, with the signed content as
        the HTTPS entity body.</t>
        -->
      </section>

      <section anchor="atoca-sec" title="Emergency Alerting">
        <t>
          緊急警報 (Emergency alerting) は IP ネットワークの緊急利用を行うものである <xref
        target="I-D.ietf-atoca-requirements"/>.
          差し迫った危険が察知されると, アラートシステムはユーザーのデバイスにアラートメッセージを送り, 危険を通知する.
          ハリケーンやトルネードなどが発生した場合には, その通り道にあたる場所のすべてのデバイスに対してアラートが送られることもある.
        </t>
        <!--
        <t>Emergency alerting is an emerging use case for IP networks <xref
        target="I-D.ietf-atoca-requirements"/>. Alerting systems allow
        authorities to warn users of impending danger by sending alert
        messages to connected devices. For example, in the event of hurricane
        or tornado, alerts might be sent to all devices in the path of the
        storm.</t>
        -->

        <t>
          アラートシステムへの最大の要件は, アタッカーが誤報を送信することができないようにすることである.
          アタッカーによる誤報送信が行われると, アタッカーが広範囲にパニックを起こすことが可能になるであろう.
          通常アラートシステムはこういったアタックを防ぐため, メッセージ送信元を厳格に管理し, なおかつメッセージ受信側ではメッセージ送信元の検証を行う.
          前者はアラート送信元のローカルセキュリティとして実施され, 後者はアラートメッセージへのデジタル署名 (チャネルベースまたはオブジェクトベース) を用いて実現される.
          オブジェクトベースのデジタル署名を採用した場合は, 署名はセキュアオブジェクト内にエンコードされる.
          チャネルベースのデジタル署名を採用した場合は, アラートメッセージを認証済かつ完全性が保護されたチャネルを経由して送ることで, "署名済" であるとして扱う.
        </t>
        <!--
        <t>The most critical security requirement for alerting systems is that
        it must not be possible for an attacker to send false alerts to
        devices. Such a capability would potentially allow an attacker to
        create wide-spread panic. In practice, alert systems prevent these
        attacks both by controls on sending messages at points where alerts
        are originated, as well as by having recipients of alerts verify that
        the alert was sent by an authorized source. The former type of control
        implemented with local security on hosts from which alerts can be
        originated. The latter type implemented by digital signatures on alert
        messages (using channel-based or object-based mechanisms).  With an
        object-based mechanism, the signature value is encoded in a secure object.
        With a channel-based mechanism, the alert is "signed" by virtue of being
        sent over an authenticated, integrity-protected channel.</t>
        -->

        <t>
          アラートは一般的に一連の中間者を経由してエンドユーザーに届けられる.
          例えば, ある国家が運営する天気予報サービスがハリケーンのアラートを送信する場合には, まずアラートメッセージを国家のゲートウェイに送り, ネットワークオペレーターがそれをエンドユーザーにブロードキャストするであろう.
        </t>
        <!--
        <t>Alerts typically reach end recipients via a series of
        intermediaries. For example, while a national weather service might
        originate a hurricane alert, it might first be delivered to a national
        gateway, and then to network operators, who broadcast it to end
        subscribers.</t>
        -->

        <t><figure anchor="fig-atoca-sec"
            title="Delivering an emergency alert">
            <artwork><![CDATA[        +------------+    +------------+    +------------+
        | Originator |    | Originator |    | Originator |
        +------------+    +------------+    +------------+
              |                 .                 .
              +-----------------+..................
                                |
                                V
                           +---------+
                           | Gateway |
                           +---------+
                                |
                   +------------+------------+
                   |                         |
                   V                         V
              +---------+               +---------+
              | Network |               | Network |
              +---------+               +---------+
                   |                         |
            +------+-----+            +------+-----+
            |            |            |            |
            V            V            V            V
        +--------+   +--------+   +--------+   +--------+
        | Device |   | Device |   | Device |   | Device |
        +--------+   +--------+   +--------+   +--------+

]]></artwork>
          </figure></t>

        <t>
          アラートメッセージへの署名を検証するためには, 受信者が信頼できるアラート送信者の正規の公開鍵を所有している必要がある.
          ここで成り立っている信頼関係は, アラートの送信経路にそった区分的なものかもしれない.
          例えば, 各ネットワークで運営されるアラート中継機それぞれがすべてのアラート送信元の証明書を所有していても, 末端のデバイスではローカルネットワーク内の中継機のみを信頼しているかもしれない.
          もしくは末端デバイスがメッセージ送信者およびローカルネットワーク中継機双方に署名されたメッセージを要求するかもしれない.
        </t>
        <!--
        <t>In order to verify alert signatures, recipients must be provisioned
        with the proper public keys for trusted alert authorities. This trust
        may be "piece-wise" along the path the alert takes. For example, the
        alert relays operated by networks might have a full set of
        certificates for all alert originators, while end devices may only
        trust their local alert relay. Or devices might require that a device
        be signed by an authorized originator and by its local network's
        relay.</t>
        -->

        <t>
          このケースでは, 1つのアラートメッセージに対して複数の署名を付与する必要がでてくる.
          そうすることで, アラートメッセージはその送信経路の任意 / 全てのエンティティによる署名を含むことができるようになる.
          なるべく複雑なことを避けるためには, ここでの署名はモジュール化され, ある署名を付ける際にそれ以前の署名を変更したり再計算する必要のないようにすべきである.
        </t>
        <!--
        <t>This scenario creates a need for multiple signatures on alert
        documents, so that an alert can bear signatures from any or all of the
        entities that processed it along the path. In order to minimize
        complexity, these signatures should be "modular", in the sense that a
        new signature can be added without a need to alter or recompute
        previous signatures.</t>
        -->
      </section>

      <section anchor="webcrypto-sec" title="Web Cryptography">
          <t>W3C Web Cryptography APIではWeb用の標準暗号API <xref target="WebCrypto"></xref>を定義している。
              もしブラウザがこのAPIを使えるようにした場合、ウェブページの一部として実行されたJavaScriptがブラウザにダイジェスト、MAC、暗号化、デジタル署名などの処理を実行させることが可能となる。</t>
      <!--<t>The W3C Web Cryptography API defines a standard cryptographic API for the
      Web <xref target="WebCrypto"></xref>.  If a browser exposes this API, then
      JavaScript provided as part of a Web page can ask the browser to perform
      cryptographic operations, such as digest, MAC, encryption, or digital signing.</t>-->

      <t>
          ブラウザが暗号処理を実行することの主要な理由の一つに、JavaScriptコードによって暗号処理に利用されるの鍵情報にアクセスできないようにすることが挙げられる。
          例えば、この分離によって、クロスサイトスクリプティング(XSS)によって注入されたコードがブラウザ内に保持された鍵を読み取ったり抜き取ったりすることを防げるだろう。
          悪意のあるコードがブラウザ上で実行し続けている間は鍵を依然として利用可能である一方、この脆弱性はユーザのブラウザ上で脆弱なページがアクティブな間のみ有効である。
      </t>
      <!--<t>One of the key reasons to have the browser perform cryptographic operations
      is to avoid allowing JavaScript code to access the keying material used for these
      operations.  For example, this separation would prevent code injected through a
      cross-site scripting (XSS) attack from reading and exfiltrating keys stored
      within a browser.  While the malicious code could still use the key while running
      in the browser, this vulnerability can only be exercised while the vulnerable
      page is active in a user's browser.</t>-->

      <t>
          しかしながら、WebCryptGraphy API は鍵のエクスポート機能も提供する。それによりJavascriptでAPIを隠蔽した形式で鍵を抜き出すことができる。
          例えば、JavaScriptは別のデバイスが保持する対になる秘密鍵の代わりに公開鍵を提供したかもしれない。
          それにより、APIが提供する隠蔽された鍵は新しいデバイスへ安全に鍵を転送するのに使うことができる。
          こうして悪意のあるコードが鍵をエクスポートできるようにする可能性があるが、ユーザへの通知や同意の検証を考慮にいれても、明示的なエクスポート処理を必要とすることが制御のポイントとなっている。
      </t>
      <!--<t>However, the WebCryptography API also provides a key export functionality,
      which can allow JavaScript to extract a key from the API in wrapped form.  For
      example, the JavaScript might provide a public key for which the corresponding
      private key is held by another device.  The wrapped key provided by the API
      could then be used to safely transport the key to the new device.  While this
      could potentially allow malicious code to export a key, the need for an explicit
      export operation provides a control point, allowing for user notification or
      consent verification.</t>-->

      <t>
          Web CryptGraphy API はブラウザが自身の扱う鍵の利用を制限することを強いることも許可している。
          例えば、対象鍵は暗号化のみでMACには利用できないこと注目されがちである。
          鍵が隠蔽された形式でエクスポートされる際、これらの属性は鍵と一緒にもっていかれるべきである。
      </t>
      <!--<t>The Web Cryptography API also allows browsers to impose limitations on the
      usage of the keys it handles.  For example, a symmetric key might be marked as
      usable only for encryption, and not for MAC.  When a key is exported in wrapped
      form, these attributes should be carried along with it.</t>-->

      <t>
          Web CryptGraphy API はこのようにして、いくつかの鍵の形式を表現するフォーマットが必要とされる。
          言うまでもなく、非対称な鍵のペアから公開鍵は自由にインポートでき、ブラウザよりエクスポート可能であるため、公開鍵を表現するためのフォーマットが必要である。
          秘密鍵や対象鍵を表現できるようなフォーマットもまた必要とされている。
          非公開鍵のために、まず第一に必要なものは鍵を暗号的に機密性および完全性が保証されている、隠蔽された形式である。
          ダイレクトで隠蔽されていないフォーマットを定義することもまた、セキュリティの境目での利用に有用であるかもしれない。
      </t>
      <!--<t>The Web Cryptography API thus requires formats to express several forms of
      keys.  Obviously, the public key from an asymmetric key pair can be freely
      imported to and exported from the browser, so there needs to be a format for
      public keys.  There is also a need for a format to express private keys and
      symmetric keys.  For non-public keys, the primary need is for a wrapped form,
      where the confidentiality and integrity of the key is assured cryptographically;
      these protections should also apply to any attributes of the key.  It may also
      be useful to define a direct, unwrapped format, for use within a security
      boundary.</t>-->
      </section>

    <section title="Constrained Devices">

      <t>
        このセクションでは <xref target="I-D.ietf-lwig-terminology"/> に定義されている制約のあるデバイスでのユースケースを示す。
        このタイプのデバイスでの典型的な問題には、限られたメモリ、限られた電源、低い処理能力、そして通信プロトコルでの厳しいサイズ制限が挙げられる。
      </t>
      <!--
      <t>This section describes use cases for constrained devices as defined
      in <xref target="I-D.ietf-lwig-terminology"/>. Typical issues with this type of
      devices are limited memory, limited power supply, low processing
      power, and severe message size limitations for the communication
      protocols.</t>
      -->

      <section title="Example: MAC based on ECDH-derived key">

        <t>
          小さく低電力なデバイスのメーカーがJOSEワーキンググループの成果を暗号化や認証のフレームワークとして採用することを決定したとしよう。
          このデバイスメーカーではゲートと電力の双方に関して共に予算の限りがある。
          このため、これらの必要量を最小化するために多数のショートカットと設計決定がなされてきた。
        </t>
        <!--
        <t>Suppose a small, low power device maker has decided on using the output of
        the JOSE working group as their encryption and authentication
        framework.  The device maker has a limited budget for both gates and
        power.  For this reason there are a number of
        short cuts and design decisions that have been made in order to
        minimize these needs.</t>
        -->

        <t>
          設計チームは、メッセージ認証コード (MAC) を使用することで必要な認証の提供には十分だろうと決定した。
          しかし彼らはMACは使用するが、単一の共有秘密鍵を長期間使用することは望まない。
          代わりに、彼らは以下に提案する検証可能な共有秘密鍵を計算により求める方式を採用する。
        </t>
        <!--
        <t>The design team has determined that the use of message authentication
        codes (MAC) is going to be sufficient to provide the necessary
        authentication.  However, although a MAC is going to be used, they do
        not want to use a single long term shared secret.  Instead they have
        adopted the following proposal for computing a shared secret that can
        be validated:</t>
        -->

        <t><list style="symbols">
          <t>
            Elliptic-Curve Diffie-Hellman (ECDH) 鍵は、デバイスの製造時に (もしくは導入時の設定処理の一環として) 生成される。
          </t>

          <t>
            コントローラー用のECDH公開鍵は、設定時にセットされる。
          </t>

          <t>
            設定システムは、ECDHの計算を行い、結果の共有秘密鍵をデバイスに設定する。
            このプロセスは、必要な指数計算をデバイス上で実施する必要をなくす。
            この計算された共有秘密鍵の保護に関するセキュリティ要件は、ECDH秘密鍵の保護に関する要件と同等である。
          </t>

          <t>
            カウンターと増分値はデバイス上に設定される。
          </t>

          <t>
            デバイスがメッセージを送信する際、カウンターはインクリメントされ、新たなMAC鍵がECDH秘密鍵とカウンター値から計算される。
            必要なMAC鍵を導出するために、AES-CBCをベースとした独自の鍵導出関数 (KDF) を用いる。
            そしてMAC鍵は、メッセージのMAC値を計算するのに用いられる。
          </t>
        </list></t>
        <!--
        <t><list style="symbols">
          <t>An Elliptic-Curve Diffie-Hellman (ECDH) key is generated for the
          device at the time of manufacturing.  (Or as part of the
          configuration process during installation.)</t>

          <t>An ECDH public key for the controller is configured at the time of
          configuration.</t>

          <t>The configuration system performs the ECDH computation and
          configures the device with the resulting shared secret.  This
          process eliminates the need for the device to be able to perform
          the required exponentiation processing.  The security requirements
          on protecting this computed shared secret are the same as the
          requirements on protecting the private ECDH key.</t>

          <t>A counter and an increment value are configured onto the device.</t>

          <t>When a message is to be sent by the device, the counter is
          incremented and a new MAC key is computed from the ECDH secret and
          the counter value.  A custom Key Derivation Function (KDF)
          function is used when is based on the AES-CBC is used to derive
          the required MAC key.  The MAC key is then used to compute the MAC
          value for the message.</t>
        </list></t>
        -->

        <t>
          システムがメッセージの機密性を提供する必要があるとき、同様の方法でKDFは、AEADアルゴリズム鍵を計算するためにも利用できる。
          より大きなデバイスのコントローラーでは、指数計算のステップを実施したり、送信元ナンス値を生成するために乱数生成器を使用するだろう。
        </t>
        <!--
        <t>In a similar manner the KDF function can used to compute an AEAD
        algorithm key when the system needs to provide confidentially for the
        message.  The controller, being a larger device will perform the
        exponentiation step and use a random number generator to generate the
        sender nonce value.</t>
        -->

      </section>
      <section title="Object security for CoAP">

        <t>
          このユースケースでは, C0/C1 クラス (<xref target="I-D.ietf-lwig-terminology"/> 参照) の制約下にあるデバイスを扱う.
          これらのデバイスは, CoAP プロトコルで RESTful リクエスト/レスポンスをやりとりする <xref target="I-D.ietf-core-coap"/>.
          問題を単純化するため, 全てのコミュニケーションはユニキャストであるものとする.
          つまり, ここで述べるセキュリティ対策はマルチキャストやブロードキャストをカバーするものではない.
        </t>
        <!--
        <t>This use case deals with constrained devices of class C0/C1 (see
        <xref target="I-D.ietf-lwig-terminology"/>). These devices communicate using RESTful
        requests and responses transferred using the CoAP protocol
        <xref target="I-D.ietf-core-coap"/>. To simplify matters, all communication is
        assumed to be unicast, i.e. these security measures don't cover
        multicast or broadcast.</t>
        -->

        <t>
          ここで対象としているような環境では, セッションベースのセキュリティ (four-pass authentication プロトコル等) は高コストすぎる可能性がある.
          データの受信や送信 (特に送信) には多くの電力が必要であり, 特にワイヤレスデバイスではこれが問題となる.
          従ってただ平文の CoAP リクエスト/レスポンスペイロードのみを JWE オブジェクトに置き換えるてセキュアにするということは, 重要な代替案である.
          そこには保護レベルとパフォーマンスのトレードオフが存在する.
          (CoAP ヘッダーは保護対象にならない)
        </t>
        <!--
        <t>In this type of setting it may be too costly to use session
        based security (e.g. to run a 4 pass authentication protocol) since
        receiving and in particular sending consumes a lot of power, in
        particular for wireless devices. Therefore to just secure the CoAP
        payload by replacing a plain text payload of a request or response
        with a JWE object is an important alternative solution, which
        allows a trade-off between protection (the CoAP headers are not
        protected) and performance.</t>
        -->

        <t>
          単純な例では, センサータイプのデバイスから返される CoAP GET レスポンスが挙げられる.
          センサーの取得データは, プライバシーセンシティブであったりビジネスセンシティブであることもあり, 完全性保護と暗号化のどちらもが必要となりうる.
        </t>
        <!--
        <t>In a simple setting, consider the payload of a CoAP GET response from
        a sensor type device. The information in a sensor reading may be
        privacy or business sensitive and needs both integrity protection and
        encryption.</t>
        -->

        <t>
          しかしながら, 一部には取得データが非常に短い (数バイト) ものもあり, このようなケースでは, デフォルトの暗号化および完全性保護アルゴリズム (128 bit AES with HMAC_SHA256 等) を利用すると, たとえ JWE ヘッダーを無視したとしても劇的にペイロードサイズを大きくしてしまう可能性がある.
        </t>
        <!--
        <t>However some sensor readings are very short, say a few bytes, and in
        this case default encryption and integrity protection algorithms
        (such as 128 bit AES with HMAC_SHA256) may cause a dramatic message
        expansion of the payload, even disregarding JWE headers.</t>
        -->

        <t>
          またある種のセンサーの取得情報は突然価値が下がることもある.
          例としては交通情報や環境データなどが挙げられる.
          こういうケースでは, 状況に応じてセキュリティオーバーヘッドを低減可能になっている必要がある.
        </t>
        <!--
        <t>Also the value of certain sensor readings may decline rapidly, e.g.
        traffic or environmental measurements, so it must be possible to
        reduce the security overhead.</t>
        -->

        <t>
          以上のことから JWE/JWS プロファイルとして以下のような要件が挙げられる.
        </t>
        <!--
        <t>This leads to the following requirements which could be covered by
        specific JWE/JWS profiles:</t>
        -->

        <t><list style="symbols">
          <t>
            セキュアオブジェクトのサイズは可能な限り小さく保たれるべきである.
            データ受信には, 公開鍵暗号処理よりもはるかに多くの電力コストがかかる.
            これは特にワイヤレス環境で顕著である.
          </t>
          <!--
          <t>The size of the secure object shall be as small as possible.
          Receiving an object may cost orders of magnitude more in terms of
          power than performing say public key cryptography on the object,
          in particular in a wireless setting.</t>
          -->

          <t>
            完全性保護:
            デジタル署名フィールドを持つなど完全性保護をサポートし, 公開鍵署名/共通鍵メッセージ認証コードをともにサポートすべきである.
          </t>
          <!--
          <t>Integrity protection:
          The object shall be able to support integrity protection, i.e. have
          a field containing a digital signature, both public key signatures
          and keyed message authentication codes shall be supported.</t>
          -->

          <t>
            暗号化:
            完全性保護の追加オプションとして暗号化をサポートすべきである.
            また特定のフィールドを暗号化対象から外して完全性検証および復号化を行える様にすべきである.
          </t>
          <!--
          <t>Encryption:
          The object shall be able to support encryption as an optional
          addition to integrity protection. It shall be possible to exclude
          certain fields from encryption which are needed before verifying
          integrity or decrypting the object.</t>
          -->

          <t>
            暗号スイート:
            制約付きデバイスのユースケースをサポートするため, 多様な暗号スイートをサポートすべきである.
            例えば
            <list style="symbols">
              <t>
                複数のブロックサイズでのブロック暗号化 (標準の128bitに加えて96bitなど)
              </t>
              <t>
                ブロックサイズ調整のためのパディングでメッセージサイズを増大させることのない AES-GCM などのブロック暗号モード
              </t>
              <t>
                暗号化と MAC 計算を同時にサポートする暗号スイート (ブロック暗号の AEAD モード等)
              </t>
            </list>
          </t>
          <!--
          <t>Cipher suites:
          It should be possible to support a variety of cipher suites to
          support the constrained devices use cases. For example:
            <list style="symbols">
              <t>Block ciphers with block sizes of e.g. 96 bits, in addition to
              the standard 128 bits</t>
              <t>Modes of operation for block ciphers that do not expand the
              message size to a block boundary, such as AES-GCM.</t>
              <t>Cipher suites that support combined encryption and MAC
              calculation (i.e., AEAD modes for block ciphers).</t>
            </list>
          </t>
          -->
        </list></t>

      </section>
    </section>

    </section>

    <section anchor="req-sec" title="Requirements">
        <t>
            この章では前章のユースケースの要件を要約を行い、またユースケースから直接的には得られないもう一歩進んだ要件を並べる。
            JOSEのシステムが採用するのに依然として望ましい特長ではあるが、厳しい要件ではない制約もまたある。
        </t>
      <!--<t>This section summarizes the requirements from the above uses cases, and
      lists further requirements not directly derived from the above use cases.
      There are also some constraints that are not hard requirements, but which
      are still desirable properties for the JOSE system to have.</t>-->

      <section anchor="functional-sec" title="Functional Requirements">
        <t><list style="hanging">
          <t hangText="F1">
              下記のセキュリティ特性を備えたセキュアオブジェクトのためのフォーマットを定義すること
            <list style="symbols">
            <t>デジタル署名 (完全性/非対象鍵のペアによる認証)</t>
            <t>メッセージ認証 (完全性/対象鍵による認証)</t>
            <t>認証済み暗号化</t>
            </list>
            つまり、このワーキンググループによって定義されたセキュアオブジェクトはCMS 署名データ、認証データ、エンベロープデータ、認証エンベロープデータオブジェクトと同等のセキュリティ特性を提供するべきだ<xref target="RFC5652"></xref> <xref target="RFC5083"></xref>.</t>
          <!--<t hangText="F1">Define formats for secure objects that provide the following
          security properties:
            <list style="symbols">
            <t>Digital signature (integrity/authentication under an asymmetric key pair)</t>
            <t>Message authentication (integrity/authentication under a symmetric key)</t>
            <t>Authenticated encryption</t>
            </list>
          That is, the secure objects defined by this working group should provide
          equivalent security properties to the CMS SignedData, AuthenticatedData,
          EnvelopedData, and AuthEnveloped data objects <xref target="RFC5652"></xref>
          <xref target="RFC5083"></xref>.</t>-->
          <t hangText="F2">
              非対称暗号アルゴリズムのための公開鍵と秘密鍵と関連付けられた属性を付帯し、隠蔽された形式の秘密鍵を含むフォーマットを定義すること。
          </t>
          <!--<t hangText="F2">Define a format for public keys and private keys for
          asymmetric cryptographic algorithms, with associated attributes, including a
          wrapped form for private keys.</t>-->
          <t hangText="F3">
              隠蔽された鍵とされていない鍵の両者を扱えるような関連属性を持つ対象鍵のためのフォーマットを定義すること。

          </t>
          <!--<t hangText="F3">Define a format for symmetric keys with associated attributes,
          allowing for both wrapped and unwrapped keys.</t>-->
          <t hangText="F4">
              上記オブジェクト個別のJSONシリアライズ機能を定義すること。
              JSON ABNF syntax <xref target="RFC4627"></xref> によると、この変換でのオブジェクトは正しくなければならない.
          </t>
          <!--<t hangText="F4">Define a JSON serialization for each of the above objects.  An object
          in this encoding must be valid according to the JSON ABNF syntax
          <xref target="RFC4627"></xref>.</t>-->
          <t hangText="F5">
              暗号化署名済みオブジェクトフォーマットのためのコンパクトでURLセーフなテキストシリアライズ機能を定義すること.
          </t>
          <!--<t hangText="F5">Define a compact, URL-safe text serialization for the encrypted
          signed object formats.</t>-->
          <t hangText="F6">
              隠蔽された鍵と関連付けられた属性を暗号的にオブジェクトにひもづけられるようにすること.
          </t>
          <!--<t hangText="F6">Allow for attributes associated to wrapped keys to be bound
          to them cryptographically</t>-->
          <t hangText="F7">
              隠蔽された鍵が対象鍵を利用するセキュアオブジェクトから区別されるようにすること。
              そのようなケースでは、隠蔽された鍵（例：暗号文、MAC値）以外のセキュアオブジェクトの暗号コンポーネントは隠蔽された鍵形式とは非依存でなくてはならない。
              例えば、暗号化オブジェクトが複数の受信者宛に準備された場合、暗号文ではなく隠蔽された鍵のみが変わる。
          </t>
          <!--<t hangText="F7">Allow for wrapped keys to be separated from a secure object
          that uses a symmetric key.  In such cases, cryptographic components of the
          secure object other than the wrapped key (e.g., ciphertext, MAC values) must
          be independent of the wrapped form of the key.  For example, if an encrypted
          object is prepared for multiple recipients, then only the wrapped key may vary,
          not the ciphertext.</t>-->
          <t hangText="F8">
              この文書記載の要件に合わせようとして、特に大量のアプリケーションの内容が保護されるような場合に、余計なオーバーヘッドを強いないようにすること。
          </t>
          <!--<t hangText="F8">Do not impose more overhead than is required to meet the
          requirements in this document, especially when a large amount of application
          content is being protected.</t>-->
        </list></t>
      </section>

      <section anchor="sec-req-sec" title="Security Requirements">
        <t><list style="hanging">
        <t hangText="S1">
          暗号化やMACの計算に同じ対称鍵を繰り返し使用することを避けるためのメカニズムを提供すること。
          その代わりに、長期間有効な鍵は鍵ラップのためだけに用いるべきであり、直接暗号化やMACに用いるべきではない。
          CMS <xref target="RFC5652"></xref> で提供されているいずれかの鍵管理手法を用いるべきである。
          <list style="symbols">
            <t>鍵配送 (公開鍵のラップ)</t>
            <t>鍵暗号化 (対称鍵のラップ)</t>
            <t>鍵合意 (DH公開鍵のラップ)</t>
            <t>パスワードベース暗号化 (パスワードから導出された鍵によるラップ)</t>
          </list>
        </t>
        <!--
        <t hangText="S1">Provide mechanisms to avoid repeated use of the same symmetric
        key for encryption or MAC computation.  Instead, long-lived keys should be used
        only for key wrapping, not for direct encryption/MAC.  It should be possible to use any
        of the key management techniques provided in CMS <xref target="RFC5652"></xref>:
          <list style="symbols">
            <t>Key transport (wrapping for a public key)</t>
            <t>Key encipherment (wrapping for a symmetric key)</t>
            <t>Key agreement (wrapping for a DH public key)</t>
            <t>Password-based encryption (wrapping under a key derived from a password)</t>
          </list>
        </t>
        -->

        <t hangText="S2">
          長期間有効な対称鍵を暗号操作に直接用いる場合 (すなわち要件S1に合致しない場合)、鍵の生存期間を制限する必要がある等の、鍵管理の実践に関するデプロイガイダンスを提供すること。
        </t>
        <!--
        <t hangText="S2">Where long-lived symmetric keys are used directly for cryptographic
        operations (i.e., where requirement S1 is not met), provide deployment guidance on
        key management practices, such as the need to limit key lifetimes.</t>
        -->

        <t hangText="S3">
          主要な検証プロセスに準拠した方法で暗号アルゴリズムを使用すること。
          例えばFIPS標準がアルゴリズムAは目的Yではなく目的Xに対して用いることとしている場合、JOSEは目的Yに対するアルゴリズムAの使用を推奨すべきではない。
        </t>
        <!--
        <t hangText="S3">Use cryptographic algorithms in a manner compatible with
        major validation processes.  For example, if a FIPS standard allows
        algorithm A to be used for purpose X but not purpose Y, then JOSE should
        not recommend using algorithm A for purpose Y.</t>
        -->

        <t hangText="S4">
          事前ネゴシエーションの有無に関わらず操作をサポートすること。
          鍵のプロビジョニング以外の設定はなくとも、セキュアオブジェクトの生成や処理は可能に違いない。
          鍵がアプリケーションのコンテキストから導出可能な場合、受信者がその適切な鍵を所持していなくとも認識可能に違いない。
        </t>
        <!--
        <t hangText="S4">Support operation with or without pre-negotiation.
        It must be possible to create or process secure objects without
        any configuration beyond key provisioning.  If it is possible for keys
        to be derived from application context, it must be possible for a recipient
        to recognize when it does not have the appropriate key.</t>
        -->
        </list></t>
      </section>

      <section anchor="desiderata-sec" title="Desiderata">
        <t><list style="hanging">
          <t hangText="D1">
            W3C WebCrypto 仕様との互換性を最大化する.
            WebCrypto ワーキンググループと協調し, サポートするアルゴリズムの選択やアルゴリズム識別子の決定を行うことなどが考えられる.
          </t>
          <!--
          <t hangText="D1">Maximize compatibility with the W3C WebCrypto
          specifications, e.g., by coordinating with the WebCrypto working group
          to encourage alignment of algorithms and algorithm identifiers. </t>
          -->

          <t hangText="D2">
            可能な限り JSON 正規化を避ける.
            その他の条件が同じであれば, オブジェクトを正規化するよりも, Base64 URL エンコーディングなどでオブジェクトをシリアライゼーションする方が好まれる.
          </t>
          <!--
          <t hangText="D2">Avoid JSON canonicalization to the extent possible.
	  That is, all other things being equal, techniques that rely
          on fixing a serialization of an object (e.g., by base64url encoding it)
          are preferred over those that require converting an object to a
          canonical form.</t>
          -->

          <t hangText="D3">
            可能な限り JOSE 暗号処理の入出力をアプリケーションによってコントロール可能にする.
            JOSE 特有の手順は可能な限り減らすべきである.
            こうすることにより JOSE のフレキシビリティは向上し, 多くの暗号プロトコルが持つ多様なニーズに応えられるようになる.
            例えば, 再暗号化や再署名の処理無しに JOSE オブジェクトを CMS などのレガシーフォーマットに変換する, といったニーズも発生するかもしれない.
          </t>
          <!--
          <t hangText="D3">Maximize the extent to which the inputs and outputs of
          JOSE cryptographic operations can be controlled by the applications, as
          opposed to involving processing specific to JOSE.  This allows JOSE the
          flexibility to address the needs of many cryptographic protocols.
          For example, in some cases, might allow JOSE objects to be translated to
          legacy formats such as CMS without the need for re-encryption or re-signing.</t>
          -->
        </list></t>
      </section>
    </section>

    <section anchor="iana-sec" title="IANA Considerations">
      <t>This document makes no request of IANA.</t>
    </section>

    <section anchor="sec-cons-sec" title="Security Considerations">
      <t>The primary focus of this document is the requirements for a
      JSON-based secure object format. At the level of general security
      considerations for object-based security technologies, the security
      considerations for this format are the same as for CMS <xref
      target="RFC5652"/>. The primary difference between the JOSE format and
      CMS is that JOSE is based on JSON, which does not have a canonical
      representation. The lack of a canonical form means that it is difficult
      to determine whether two JSON objects represent the same information,
      which could lead to vulnerabilities in some usages of JOSE.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5083.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6120.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6708.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml"?>


      <?rfc include="http://xml.resource.org/public/rfc/bibxml2/reference.W3C.REC-xml.xml" ?>

      <reference anchor="WebCrypto">
        <front>
          <title>Web Cryptography API</title>
          <author fullname="" initials="R" surname="Sleevi"/>
          <author fullname="" initials="D" surname="Dahl"/>
          <date month="January" year="2013"/>
        </front>
      </reference>
    </references>

    <references title="Informative References">

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5322.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5751.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3207.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3923.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-saml2-bearer.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-jwt-bearer.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-lwig-terminology.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-coap.xml' ?>

      <!--
      <?rfc include="http://xml.resource.org/public/rfc/bibxml2/reference.ITU.X690.1994.xml" ?>
      -->
      <reference anchor="ITU.X690.2002">
          <front>
              <title>
      Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)
              </title>
              <author>
                  <organization>International Telecommunications Union</organization>
              </author>
              <date month="" year="2002"/>
          </front>
          <seriesInfo name="ITU-T" value="Recommendation X.690"/>
      </reference>


      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-jose-json-web-signature.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-jose-json-web-encryption.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-jose-json-web-key.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-jose-json-web-algorithms.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-alto-protocol.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-atoca-requirements.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-json-web-token.xml"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml2/reference.W3C.xmldsig-core.xml" ?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml2/reference.W3C.xmlenc-core.xml" ?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.miller-xmpp-e2e.xml"?>
      <!--
      <reference anchor='I-D.miller-xmpp-e2e'>
        <front>
          <title>End-to-End Object Encryption and Signature for the Extensible Messaging and Presence Protocol (XMPP)</title>
          <author fullname="" initials="M" surname="Miller" />
          <date month='February' day='25' year='2013' />
      </front>

      <seriesInfo name='Internet-Draft' value='draft-miller-xmpp-e2e-06' />
      <format type='TXT'
              target='http://www.ietf.org/internet-drafts/draft-miller-xmpp-e2e-06.txt' />
      </reference>
      -->

      <reference anchor="CAP">
        <front>
          <title>Common Alerting Protocol v1.1</title>
          <author fullname="" initials="A" surname="Botterell"/>
          <author initials="E." surname="Jones"/>
          <date month="October" year="2005"/>
        </front>
      </reference>

      <reference anchor="OpenID.Messages"
                 target="http://openid.net/specs/openid-connect-messages-1_0.html">
        <front>
          <title>OpenID Connect Messages 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B."
                  surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

          <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
            <organization abbrev="Salesforce">Salesforce</organization>
          </author>

          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="Illumila">Illumila</organization>
          </author>

          <date day="3" month="May" year="2013"/>
        </front>
      </reference>

      <reference anchor="WS-Federation"
                 target="http://docs.oasis-open.org/wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html">
        <front>
          <title>Web Services Federation Language (WS-Federation) Version 1.2</title>

          <author fullname="Chris Kaler" initials="C." surname="Kaler">
            <organization/>
          </author>

          <author fullname="Michael McIntosh" initials="M." surname="McIntosh">
            <organization/>
          </author>

          <author fullname="Marc Goodner" initials="M." surname="Goodner">
            <organization/>
          </author>

          <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
            <organization/>
          </author>

          <date day="22" month="May" year="2009"/>
        </front>
      </reference>

      <reference anchor="Persona">
	<front>
	  <title>Mozilla Persona</title>

	  <author fullname="Mozilla">
	    <organization abbrev="Mozilla">Mozilla</organization>
	  </author>

	  <date month="April" year="2013" />
	</front>

	<format target="https://developer.mozilla.org/en-US/docs/Persona" type="HTML" />
      </reference>

    </references>

    <section anchor="ack-sec" title="Acknowledgements">
      <t>Thanks to Matt Miller for discussions related to XMPP end-to-end
      security model, and to Mike Jones for considerations related to security
      tokens and XML security.  Thanks to Mark Watson for raising the need for
      representing symmetric keys and binding attributes to them.  Thanks to
      Ludwig Seitz for contributing the constrained device use case.</t>
    </section>

    <section title="Document History" anchor="hist-sec">
      <t>
	[[ to be removed by the RFC editor before publication as an RFC ]]
      </t>

      <t>
        -03
        <list style='symbols'>
          <t>Replaced the "small device" case with the "constrained device" case</t>
          <t>Added S2 to cover cases where the WG decides not to implement S1</t>
          <t>Addressed multiple other WGLC comments</t>
        </list>
      </t>

      <t>
        -02
        <list style='symbols'>
          <t>
            Referenced the JWS, JWE, JWK, and JWA specifications
	    making the "signed object format", "encrypted object format",
	    "key format", and algorithms resulting from these use cases concrete.
          </t>
	  <t>
	    Added "Requirements on Application Protocols" section.
	  </t>
	  <t>
	    Broke former huge "Security Tokens and Authorization" Use Case section
	    into "Security Tokens", "OAuth", and "Federation" Use Case sections.
	  </t>
	  <t>
	    Cited Mozilla Persona as a single-sign-on (SSO) system using JWTs
	    and JOSE data formats.
	  </t>
	  <t>
	    Spelling and grammar corrections.
	  </t>
        </list>
      </t>
      <t>
        -01
        <list style="symbols">
          <t>Added the "Small Devices" use case</t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-barnes-jose-use-cases-01 with some additions.
          </t>
        </list>
      </t>
    </section>

  </back>
</rfc>
